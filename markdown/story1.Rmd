---
title: "story1"
output: html_document
---

```{r setup, include=FALSE, echo=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r}
library(sf)
library(parlitools)
library(here)
library(ggfortify)
library(patchwork)
library(stringr)
library(here)
library(GGally)
library(spatialreg)
library(spdep)
library(broom)
library(spgwr)
library(gridExtra)
library(grid)
library(Hmisc)
library(MASS)
library(stargazer)
library(car)
library(factoextra)
library(GWmodel)
library(sjPlot)
library(sjmisc)
library(sjlabelled)
library(ggpubr)
library(RColorBrewer)
library(tidyverse)
library(kableExtra)
library(mgcv)
library(colorspace)
library(gclus)
library(corrplot)
library(lme4)
library(ggplot2); theme_set(theme_dark())
rm(list=ls())
here()
```

### Research Question

The 2019 UK General Election saw the Conservative Party improve their position dramatically in the House of Commons. Not only did they hold the largest number of seats, as in the previous election of 2017, but now they held a landslide overall majority of 80 seats. Many of the gains which the Conservatives made were in seats which were long-held by Labour candidates, often referred to as the *'red wall'*. These are a set of constituencies in England and Wales, mainly in the Midlands, Northern England, and North East Wales, which have historically tended to support the Labour party. These areas were also generally associated with high levels of support for leaving the EU in the Brexit referendum. It is often pointed out that there is a temptation for political commentators in the popular press to speak of regions such as these as though they were a monolith - all composed of similarly thinking and similarly motivated individuals. This project aims to use census data and the results of the election in each constituency to examine the degree to which each of several socio-economic characteristics impacted the observed change in Conservative vote, and how this varied across the country. In particular, I wish to see if the change in voting pattern which undeniably occurred in these *'red wall'* seats has one simple explanation which applies across the region, or if different factors are at play in different parts of this traditional Labour stronghold.

------------------------------------------------------------------------

```{r}
all_elections <- readRDS(here("data", "all_elections.rds"))
constituency_polygons <- readRDS(here("data", "constituency_polygons.rds"))
```

```{r}
# dfs WITHOUT Isle of Wight
all_elections1 <- all_elections %>% 
# options for experimenting with different dependent variable structures...
#  mutate(con_change1 = con_19) %>% 
#  mutate(con_change1 = log( (con_19/(1-con_19)) / (con_17/(1-con_17)) )) %>% 
  mutate(con_change1 = 100*(con_19 - con_17) / (100 - con_17)) %>% 
  filter(!is.na(con_change1)) %>% 
  filter(country != "Scotland") %>%
  mutate(over65 = age_65_to_74 + age_75_to_84 + age_85_to_89 + age_90_plus,
         low_qual = qual_none + qual_level_1,
         deprived = deprived_2 + deprived_3 + deprived_4,
         student = economically_inactive_student,
         leave_EU = leave_hanretty,
         log_density = log(population_density),
         born_elsewhere = born_ireland + born_other_eu + born_other_pre_2004_eu + born_post_2004_eu + born_other,
         density = population_density, 
         con_flip = ifelse(winner_19 == "Conservative" & winner_17 != "Conservative", 1, 0)) %>% 
  subset(county != "Isle of Wight") %>% 
  mutate(county = factor(county))
# df with detailed constituency sf polygons for contiguity computations
all_elections_polygons <- left_join(all_elections1 %>% st_drop_geometry(), 
                                    constituency_polygons, by = c("ons_const_id" = "pcon19cd")) %>% 
  st_as_sf()
# df with simplified constituency sf polygons for making maps
all_elections_polygons_simp <- left_join(all_elections1 %>% st_drop_geometry(), 
                                    constituency_polygons, by = c("ons_const_id" = "pcon19cd")) %>% 
  st_as_sf() %>% 
  st_simplify(dTolerance = 1000)
# df with detailed county sf polygons for contiguity computations
counties <- readRDS(here("data", "counties.rds")) %>% 
  subset(county != "Isle of Wight") %>% 
  mutate(county = factor(county))
# df with simplified county sf polygons for making maps
counties_simp <-readRDS(here("data","counties_simp.rds")) %>% 
  subset(county != "Isle of Wight") %>% 
  mutate(county = factor(county))
# weighted means for variables at county level, weights by size of electorate
wmeans <- readRDS(here("data","wmeans.RDS")) %>% 
  subset(county != "Isle of Wight")
# weighted means for centred variables
wmeans_centred <- readRDS(here("data","wmeans_centred.RDS")) %>% 
  subset(county != "Isle of Wight")
wmeans_regions <- all_elections_polygons %>% 
  st_drop_geometry() %>% 
  select(con_change1, over65, deprived, total_vote_19, region) %>% 
  group_by(region) %>% 
  summarise(con_change1 = weighted.mean(con_change1, total_vote_19), 
            over65 = weighted.mean(over65, total_vote_19), 
            deprived = weighted.mean(deprived, total_vote_19))
# regions <- all_elections_polygons %>%
#   dplyr::select(region, geometry) %>%
#   st_as_sf() %>%
#   group_by(region) %>%
#   summarise()
# saveRDS(regions, here("data","regions.rds"))
regions <- readRDS(here("data","regions.rds"))
regions$region <- factor(regions$region)
# regions_simp <- regions %>% 
#   st_simplify(dTolerance = 1000)
# saveRDS(regions_simp, here("data","regions_simp.rds"))
regions_simp <- readRDS(here("data","regions_simp.rds"))
regions_simp$region <- factor(regions_simp$region)
# df showing seats which flipped to conservatives, for overlaying on map
flip_df <- all_elections_polygons_simp %>% 
  filter(con_flip == 1)
```

### Context

Presented below are the the seats in England and Wales viewed firstly in terms of the size of the rise (or fall) of the conservative vote in 2019 from 2017. The next map shows the seats which actually flipped from another party to the Conservatives. Also shown, below these, are the ranking of the increase in Conservative votes across all the constituencies.

```{r, fig.height=6, fig.width=12}
all_elections_polygons_simp <- all_elections_polygons_simp %>% 
  mutate(con_flip = factor(ifelse(winner_19 == "Conservative" & winner_17 != "Conservative", 1, 0)),
         con_19gain = con_19 - con_17) %>% 
  arrange(con_19gain) %>% 
  mutate(con_gain_rank = seq(from = 571, to = 1, by = -1)) %>% 
  arrange(pano) %>% 
  mutate(labour19 = factor(ifelse(winner_19 == "Labour", 1, 0)), 
         labour17 = factor(ifelse(winner_17 == "Labour", 1, 0)),
         labour15 = factor(ifelse(winner_15 == "Labour", 1, 0)),
         labour10 = factor(ifelse(winner_10 == "Labour", 1, 0)))
  
cgainvotes <- ggplot(all_elections_polygons_simp) + geom_sf(aes(fill=con_19gain),lwd=0.1) + 
  scale_fill_continuous_diverging(palette = 'Blue_Red3', mid = 0, rev=TRUE) + 
  labs(title = "Conservatives Vote Change 2019/17", fill="%")  + 
  coord_sf(datum = NA) + 
  theme_classic2() +
  theme(panel.border = element_rect(colour = "darkblue", fill=NA, size = 1))
cgainseat <- ggplot(all_elections_polygons_simp) + geom_sf(aes(fill=con_flip),lwd=0.1) + 
  scale_fill_manual(values = c("white","darkblue")) + 
  labs(title = "Conservatives Gain Seats")  + 
  coord_sf(datum = NA) + 
  theme_classic2() +
  theme(panel.border = element_rect(colour = "darkblue", fill=NA, size = 1))
#cgainvotes + cgainseat
xxx <- ggplot(all_elections_polygons_simp) + geom_sf(aes(fill=con_gain_rank),lwd=0.1) + 
  scale_fill_continuous_sequential(palette = "Lajolla", rev=TRUE) + 
  labs(title = "Conservatives Gain Ranked: 1 - 571")  + 
  coord_sf(datum = NA) + 
  theme_classic2() +
  theme(panel.border = element_rect(colour = "darkblue", fill=NA, size = 1))

cgainvotes + cgainseat + xxx
```

These maps show the collapse of Labour's *'red wall'* in 2019 and where exactly these constituencies are located. A clear shrinkage is visible across Northern Wales and England.

```{r, fig.height=6, fig.width=12}
l10 <- ggplot(all_elections_polygons_simp) + geom_sf(aes(fill=labour10),lwd=0.1) + 
  scale_fill_manual(values = c("white","darkred")) + 
  labs(title = "Red Wall", subtitle = "Labour Seats 2010")  + 
  coord_sf(datum = NA) + 
  theme_classic2() +
  theme(legend.position="none", 
        panel.border = element_rect(colour = "darkred", fill=NA, size = 1))
l15 <- ggplot(all_elections_polygons_simp) + geom_sf(aes(fill=labour15),lwd=0.1) + 
  scale_fill_manual(values = c("white","darkred")) + 
  labs(title = "Red Wall", subtitle = "Labour Seats 2015") + 
  coord_sf(datum = NA) + 
  theme_classic2() +
  theme(legend.position="none", 
        panel.border = element_rect(colour = "darkred", fill=NA, size = 1))
l17 <- ggplot(all_elections_polygons_simp) + geom_sf(aes(fill=labour17),lwd=0.1) + 
  scale_fill_manual(values = c("white","darkred")) + 
  labs(title = "Red Wall", subtitle = "Labour Seats 2017") + 
  coord_sf(datum = NA) + 
  theme_classic2() +
  theme(legend.position="none", 
        panel.border = element_rect(colour = "darkred", fill=NA, size = 1))
l19 <- ggplot(all_elections_polygons_simp) + geom_sf(aes(fill=labour19),lwd=0.1) + 
  scale_fill_manual(values = c("white","darkred")) + 
  labs(title = "'Collapse of Red Wall'", subtitle = "Labour Seats 2019") + 
  coord_sf(datum = NA) +  
  theme_classic2() +
  theme(legend.position="none", 
        panel.border = element_rect(colour = "darkred", fill=NA, size = 1))

ggarrange(l10, l15, l17, l19,  
          ncol=4, nrow=1, common.legend = TRUE, legend="right")
```

### Description of Variables

I have restricted my analysis to England and Wales where this general increase in Conservative vote was observed. Scotland and in particular Northern Ireland have very different political dynamics at play.

### Response Variable:

$\begin{aligned}\LARGE{con\_change_1 = \frac{100(con\_19 - con\_17)}{(100 - con\_17)}}\end{aligned}$

```{=tex}
\begin{center}
#### "percentage of those who didn't vote conservative last time who did this time"
\end{center}
```
```{r, fig.height=4, fig.width=4}
a1 <- ggplot(all_elections1) + geom_histogram(aes(x=con_change1), colour="darkred", fill="darkblue") + 
  labs(title = "Histogram Of Dependent Variable In 571 Constituencies") + 
  theme_bw()

a1

```

```{r, fig.height=6, fig.width=12}

noflip_df <- all_elections_polygons_simp %>% 
  filter(con_flip == 0)

a2 <- ggplot(all_elections_polygons_simp) + 
  geom_sf(aes(fill=con_change1), lwd=0.15, colour="black") +
  scale_fill_continuous_diverging(palette = 'Blue_Red3', mid = 0, rev=TRUE) + 
  labs(title = "Dependent Variable Map", 
       subtitle = "Percentage Change Per Constituency")

a3 <- ggplot(all_elections_polygons_simp) + 
  geom_sf(aes(fill=con_change1), lwd=0.15, colour="black") + 
  geom_sf(data=noflip_df, alpha=0.9,lwd=.6, colour="white") +
  scale_fill_continuous_diverging(palette = 'Blue-Red3', mid = 0, rev=TRUE) + 
  geom_sf(data=flip_df, alpha=0,lwd=.6, colour="darkred") +   
  labs(title = "Dependent Variable Map", 
       subtitle = "Red Lines Denote New Conservative Wins")

ggarrange(a2, a3,  
          ncol=2, nrow=1, common.legend = TRUE, legend="right")

```

### Explanatory Variables

I have chosen the following explanatory variables, which provide a broad sweep of the composition of each constituency:

```{r, fig.height=6, fig.width=12}
par(mfrow=c(1,2))
subset1 <- all_elections_polygons %>% 
  dplyr::select(con_change1, 
                low_qual, 
                over65, 
                student, 
                deprived, 
                log_density, 
                leave_EU, 
                house_owned, 
                unemployed, 
                born_elsewhere
                ) %>% 
  st_drop_geometry()
subset1 %>% 
  cor() %>% 
  corrplot.mixed(order = 'AOE', tl.col = 'black', tl.pos = 'lt')
subset2 <- subset1 %>% 
  dplyr::select(con_change1, 
#                low_qual, 
                over65, 
#                student, 
                deprived, 
#                log_density, 
#                leave_EU, 
#                house_owned, 
#                unemployed, 
#                born_elsewhere
                )
subset2 %>% 
  cor() %>% 
  corrplot.mixed(order = 'AOE', tl.col = 'black')
```

These are the nine variables which I extracted from the census dataset which I felt could be meaningful in terms of voting patterns.

However, they not surprisingly display high levels of correlation.

I have decided to use just two in the following models.

'deprived' represents a lot of the same information as 'low_qual' and 'unemployed'.

'over65' represents a lot of the same information as 'student', 'log_density', 'house_owned' and 'born_elsewhere'.

Furthermore, 'deprived' and 'over 65' show a low level of mutual correlation.

------------------------------------------------------------------------

#### Ordinary Linear Model: By Constituency

A one percent increase of 'over65's or 'deprived's in a constituency, controlling for the other, leads to a increase of approximately 0.7% in the percentage of non-Conservative voters who changed their vote to Conservatives.

```{r}
model1 <- lm(con_change1 ~ ., data=subset2)
summary(model1)

model1.1 <- lm(con_change1 ~.+I(deprived^2), data=subset2)
summary(model1.1)

model1.2 <- lm(con_change1 ~deprived+over65+I(deprived^2), data=subset2)
summary(model1.2)

```

```{r,fig.height=6,fig.width=8}
par(mfrow=c(2,2))
plot(model1)

par(mfrow=c(2,2))
plot(model1.1)
```

#### Presence Of Spatial Autocorrelation

```{r, fig.height=6, fig.width=12}

mod1_resids <- model1$residuals
mod1_resids_df <- cbind(all_elections_polygons_simp$geometry,mod1_resids) %>% 
  as.data.frame() %>% 
  st_as_sf(crs=4326) %>% 
  mutate(mod1_resids = as.numeric(mod1_resids))
z1 <- ggplot(mod1_resids_df) + 
  geom_sf(aes(fill = mod1_resids), lwd=0.1)  +
  scale_fill_continuous_diverging(palette = 'Green-Orange', mid = 0,
                       name= "OLS Residuals")                      
                  
mod1.1_resids <- model1.1$residuals
mod1.1_resids_df <- cbind(all_elections_polygons_simp$geometry,mod1.1_resids) %>% 
  as.data.frame() %>% 
  st_as_sf(crs=4326) %>% 
  mutate(mod1.1_resids = as.numeric(mod1.1_resids))
z2 <- ggplot(mod1.1_resids_df) + 
  geom_sf(aes(fill = mod1.1_resids), lwd=0.1)  +
  scale_fill_continuous_diverging(palette = 'Green-Orange', mid = 0,
                       name= "OLS with (deprived)^2 Residuals")

z1 + z2

```



#### LISA Clusters Residuals

```{r}

neighbours1 <- poly2nb(all_elections_polygons)
weights1 <- nb2listw(neighbours1, style="B", zero.policy = T)

do.lisa <- function(x){

all_elections_polygons_simp_tablex <- cbind(all_elections_polygons$geometry,as.data.frame(x))
locali <- localmoran(all_elections_polygons_simp_tablex[,2], weights1, zero.policy = TRUE)

######

# Plot LISA clusters

quadrant <- vector(mode="numeric",length=nrow(locali))

# centers the variable of interest around its mean
m.conchange <- all_elections_polygons_simp_tablex[,2] - mean(all_elections_polygons_simp_tablex[,2])     

# centers the local Moran's around the mean
m.local <- locali[,1] - mean(locali[,1])    

# significance threshold
signif <- 0.1 

# builds a data quadrant, define the high-high, low-low, low-high and high-low categories,
# and places non-significant Moran in the category 0.
quadrant[m.conchange >0 & m.local>0] <- 4  
quadrant[m.conchange <0 & m.local<0] <- 1      
quadrant[m.conchange <0 & m.local>0] <- 2
quadrant[m.conchange >0 & m.local<0] <- 3
quadrant[locali[,5]>signif] <- 0   

# plot in r
brks <- c(0,1,2,3,4)
colors <- c("white","blue",rgb(0,0,1,alpha=0.4),rgb(1,0,0,alpha=0.4),"red")
plot(all_elections_polygons_simp$geometry, border="gray", col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
box()
legend("bottomleft", legend = c("insignificant","low-low","low-high","high-low","high-high"),
       fill=colors, bty="n")
title(main = paste("LISA Clusters: ", deparse(substitute(x))))
}

do.lisa(mod1.1_resids)

mod1.2_resids <- model1.2$residuals
do.lisa(mod1.2_resids)
```




------------------------------------------------------------------------

### Linear Mixed Model - Random Intercept and Slope by county

```{r, fig.width=4, fig.height=4}
model2.2 <- lmer(con_change1 ~ 1 + over65 + deprived+ (over65+deprived|county), 
               data=all_elections_polygons)
summary(model2.2)
plot(model2.2)
```

------------------------------------------------------------------------

```{r, fig.height=6, fig.width=12}
fix_efs <- fixef(model2.2) # fixed effects
# combine fixed and random effects into dataframe
effects <- ranef(model2.2)$county %>% #
  cbind(counties_simp$geometry) %>% 
  rename(rand_intercept = `(Intercept)`,
         rand_slope_over65 = over65,
         rand_slope_deprived = deprived) %>% 
  mutate(fix_intercept = rep(fix_efs[1],52),
         fix_slope_over65 = rep(fix_efs[2],52), 
         fix_slope_deprived = rep(fix_efs[3],52),
         slope_both_over65 = rand_slope_over65 + fix_slope_over65,
         slope_both_deprived = rand_slope_deprived + fix_slope_deprived) %>% 
  rownames_to_column("county") %>% 
  as.data.frame() %>% 
  st_as_sf()
pp1 <- ggplot(effects) + geom_sf(aes(fill=slope_both_over65)) +
  scale_fill_continuous_diverging(palette = 'Blue_Red3', mid = 0, rev=TRUE, name="Over 65") + 
  geom_sf(data=counties_simp, alpha=0,lwd=.25, colour="black") + 
  labs(title = "Random + Fixed Effects: Slope")
pp2 <- ggplot(effects) + geom_sf(aes(fill=slope_both_deprived)) +
  scale_fill_continuous_diverging(palette = 'Blue_Red3', mid = 0, rev=TRUE, name="Deprived") + 
  geom_sf(data=counties_simp, alpha=0,lwd=.25, colour="black") + 
  labs(title = "Random + Fixed Effects: Slope")
pp3 <- ggplot(effects) + geom_sf(aes(fill=rand_slope_over65)) +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Over 65") + 
  geom_sf(data=counties_simp, alpha=0,lwd=.25, colour="black") + 
  labs(title = "Random Effects: Slope")
pp4 <- ggplot(effects) + geom_sf(aes(fill=rand_slope_deprived)) +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Deprived") + 
  geom_sf(data=counties_simp, alpha=0,lwd=.25, colour="black") + 
  labs(title = "Random Effects: Slope")
```

------------------------------------------------------------------------

Coefficient estimates for random slopes per county from linear mixed model.

#### Values on caterpillar plot

```{r, fig.height=6, fig.width=12}
flip_county <- all_elections_polygons %>% 
  filter(con_flip ==1)
flip_county <- unique(flip_county$county)

df <- as.data.frame(ranef(model2.2, condVar=TRUE)) %>% 
  mutate(flip = factor(ifelse(grp %in% flip_county, "Yes", "No")), 
         se = condsd/sqrt(length(df)/3), # the df is long, with three variables
         CI = 1.65*se)

ggplot(data = df[1:52,], aes(x = grp, y = condval, ymin = condval-CI, ymax = condval+CI)) +
  geom_errorbar(aes(colour=flip), position = position_dodge(width = 0.2), width = 0.1) +
  geom_point(position = position_dodge(width = 0.2)) +
  coord_flip() + 
  geom_hline(yintercept = 0, colour="red") +
  scale_colour_manual(values = c("grey", "black")) +
  theme_classic() + 
  labs(title = "Linear Mixed Effects Model: 90% Confidence Interval\nRandom Intercept", 
       colour = "County contains\nnew Conservative\nconstituencies") +
  ylab("Value") + 
  xlab("County") 

df1 <- df[53:104,] %>% 
  arrange(condval) %>% 
  mutate(grp = factor(grp, levels=grp))

ggplot(data = df1, aes(x = grp, y = condval, ymin = condval-CI, ymax = condval+CI)) +
  geom_errorbar(aes(colour=flip), position = position_dodge(width = 0.2), width = 0.1) +
  geom_point(position = position_dodge(width = 0.2)) +
  coord_flip() + 
  geom_hline(yintercept = 0, colour="red") +
  scale_colour_manual(values = c("grey", "black")) +
  theme_classic() + 
  labs(title = "Linear Mixed Effects Model: 90% Confidence Interval\nRandom Intercept: over65", 
       colour = "County contains\nnew Conservative\nconstituencies") +
  ylab("Value") + 
  xlab("County") 

df2 <- df[105:156,] %>% 
  arrange(condval) %>% 
  mutate(grp = factor(grp, levels=grp))

ggplot(data = df2, aes(x = grp, y = condval, ymin = condval-CI, ymax = condval+CI)) +
   geom_errorbar(aes(colour=flip), position = position_dodge(width = 0.2), width = 0.1) +
  geom_point(position = position_dodge(width = 0.2)) +
  coord_flip() + 
  geom_hline(yintercept = 0, colour="red") +
  scale_colour_manual(values = c("grey", "black")) +
  theme_classic() + 
  labs(title = "Linear Mixed Effects Model: 90% Confidence Interval\nRandom Intercept: deprived", 
       colour = "County contains\nnew Conservative\nconstituencies") +
  ylab("Value") + 
  xlab("County")  

df <- df %>% 
  mutate(significance = factor(
    ifelse(condval-CI <0 & condval+CI <0, "negative", 
                      ifelse(condval-CI >0 & condval+CI >0, "positive", "not significant")))
         ) %>% 
  cbind(rep(counties_simp$geometry,3)) %>% 
  st_as_sf()
```

```{r, fig.height=6, fig.width=12}
ggarrange(pp1,pp2,
          ncol=2, nrow=1, common.legend = FALSE, legend="right")
ggarrange(pp3,pp4, 
          ncol=2, nrow=1, common.legend = FALSE, legend="right")
```

```{r, fig.height=6, fig.width=12}
b1 <- ggplot(df[1:52,]) + 
  geom_sf(aes(fill=significance)) + 
  labs(title = "Random Intercept: Significance 90%", 
       subtitle = "Red Lines Denote New Conservative Wins", 
       fill = "Neg/Pos\nAddition\nto Slope") + 
  scale_fill_manual(values = c("negative" = "lightblue3",
                                "positive"="burlywood3",
                                "not significant"="white")) + 
  geom_sf(data=flip_df, alpha=0,lwd=.35, colour="darkred")
b2 <- ggplot(df[53:104,]) + 
  geom_sf(aes(fill=significance)) + 
  labs(title = "Random Slope (Over 65): Significance 90%", 
       subtitle = "Red Lines Denote New Conservative Wins", 
       fill = "Neg/Pos\nAddition\nto Slope") + 
  scale_fill_manual(values = c("negative" = "lightblue3",
                                "positive"="burlywood3",
                                "not significant"="white")) + 
  geom_sf(data=flip_df, alpha=0,lwd=.35, colour="darkred")
b3 <- ggplot(df[105:156,]) + 
  geom_sf(aes(fill=significance)) + 
  labs(title = "Random Slope (Deprived): Significance 90%", 
       subtitle = "Red Lines Denote New Conservative Wins", 
       fill = "Neg/Pos\nAddition\nto Slope") + 
  scale_fill_manual(values = c("negative" = "lightblue3",
                                "positive"="burlywood3",
                                "not significant"="white")) + 
  geom_sf(data=flip_df, alpha=0,lwd=.35, colour="darkred")
#b1
ggarrange(b2, b3,  
          ncol=2, nrow=1, common.legend = TRUE, legend="right")
```

------------------------------------------------------------------------

### Problems with LMM in this context

1.  Constituencies, however, are not independent observations.

2.  MAUP.

------------------------------------------------------------------------

#### Different approach

To account for non-independence (spatial autocorrelation) and MAUP (constituencies are the smallest recorded observation level), I will use a Generalised Additive Model (GAM). This will feature as a component a Conditional Autoregressive (CAR) model, which is an example of a Markov Random Field (MRF). It is also a multi-level model.

**First model:**

Conservative Change = $\alpha + \beta_{1}x_{1} + \beta_{2}x_{2} + \gamma_{0j} + \gamma_{1j}x_{1}$

-   with $\gamma_{0j} \sim CAR(\tau_{0}^{2})$, and $\gamma_{1j} \sim CAR(\tau_{1}^{2})$

$\beta_{1}$ - over65

$\beta_{2}$ - deprived

$\gamma_{1j}$ - effect from 'over65' of being in geographical area $j$

**Second model:**

Conservative Change = $\alpha + \beta_{1}x_{1} + \beta_{2}x_{2} + \gamma_{0j} + \gamma_{2j}x_{2}$

-   with $\gamma_{0j} \sim CAR(\tau_{0}^{2})$, and $\gamma_{2j} \sim CAR(\tau_{2}^{2})$

$\beta_{1} - over65$

$\beta_{2} - deprived$

$\gamma_{2j}$ - effect from 'deprived' of being in geographical area $j$

------------------------------------------------------------------------

#### GAM with CAR: county level

##### Over 65

```{r}
# make adjacency list for counties
nlist <- counties %>% st_touches()
names(nlist) <- counties$county
# Isle of Wight[26] is island county. Make it adjacent to West Sussex[51] and Hampshire[22]
# nlist[51]$`West Sussex` <- c(16,22,26,46)
# nlist[22]$Hampshire <- c(3,13,26,46,51,53)
# nlist[26]$`Isle of Wight` <- c(22,51)
```

```{r}
model3.1 <- gam(con_change1 ~ over65 + deprived + I(deprived^2) + 
                 s(county,bs='mrf',xt=list(nb=nlist)) +
                 s(county,bs='mrf',xt=list(nb=nlist), 
                   by=over65,k=2),
               data=all_elections_polygons, family=gaussian, 
               weight=total_vote_19, method='REML')
summary(model3.1)
county_extract1 <- tibble(over65=rep(1,52), 
                          deprived=rep(0,52),
                          county=levels(counties$county),
                         `county:over65`=levels(counties$county)) 
# df for holding results with simplified county boundaries for plotting
counties_simp1 <- counties_simp %>% 
  mutate(agamma_i = predict(model3.1, newdata = county_extract1))
a3.1 <- ggplot(counties_simp1,aes(fill=agamma_i)) + 
  geom_sf(lwd=.25, colour="black") +
  scale_fill_distiller(name=expression(alpha+gamma[i]),direction=1)
counties_simp1 <- counties_simp1 %>% 
  mutate(gamma_i = predict(model3.1,  newdata = county_extract1, type='terms')[,4], 
         rand_slope_over65 = (gamma_i / wmeans$over65), 
         fix_slope_over65 = rep(model3.1$coefficients[2]), 
         total_slope_over65 = rand_slope_over65 + fix_slope_over65)
b3.1 <- ggplot(counties_simp1,aes(fill=gamma_i)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_distiller(type='div',
                       name=expression(gamma[over65]))
c3.1 <- ggplot(counties_simp1,aes(fill=rand_slope_over65)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Over 65") + 
  labs(title = "Random Slope")
d3.1 <- ggplot(counties_simp1,aes(fill=total_slope_over65)) +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Over 65") + 
  labs(title = "Fixed + Random Slope")
```

#### GAM with CAR county level

##### Deprived

```{r}
model3.2 <- gam(con_change1 ~ over65 + deprived + 
                 s(county,bs='mrf',xt=list(nb=nlist)) +
                 s(county,bs='mrf',xt=list(nb=nlist), 
                   by=deprived,k=2), 
               data=all_elections_polygons, family=gaussian, 
               weight=total_vote_19, method='REML')
summary(model3.2)
county_extract2 <- tibble(over65=rep(1,52), 
                          deprived=rep(1,52),
                          county=levels(counties$county),
                         `county:deprived`=levels(counties$county)) 
counties_simp2 <- counties_simp %>% 
  mutate(agamma_i = predict(model3.2, newdata = county_extract2))
a3.2 <- ggplot(counties_simp2,aes(fill=agamma_i)) + 
  geom_sf(lwd=.25, colour="black") +
  scale_fill_distiller(name=expression(alpha+gamma[0]),direction=1)
counties_simp2 <- counties_simp2 %>% 
  mutate(gamma_i = predict(model3.2, newdata = county_extract2, type='terms')[,4], 
         rand_slope_deprived = (gamma_i / wmeans$deprived), 
         fix_slope_deprived = predict(model3.2, newdata = county_extract2,type='terms')[,2], 
         total_slope_deprived = rand_slope_deprived + fix_slope_deprived)
b3.2 <- ggplot(counties_simp2,aes(fill=gamma_i)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_distiller(type='div',
                       name=expression(gamma[deprived]))
c3.2 <- ggplot(counties_simp2,aes(fill=rand_slope_deprived)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Deprived") + 
  labs(title = "Random Slope")
d3.2 <- ggplot(counties_simp2,aes(fill=total_slope_deprived)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Deprived") + 
  labs(title = "Fixed + Random Slope")
```

```{r, fig.height=6, fig.width=12}
# ggarrange(d3.1,d3.2, 
#           ncol=2, nrow=1, common.legend = FALSE, legend="right")
ggarrange(c3.1,c3.2, 
          ncol=2, nrow=1, common.legend = FALSE, legend="right")
```

------------------------------------------------------------------------

#### GAM with CAR region level

##### Over 65

```{r}
# fix and set up contiguity situation
all_elections_polygons$region <- factor(all_elections_polygons$region)
# contiguity list
nlist3 <- regions %>% st_touches()
names(nlist3) <- regions$region
# first, GAM CAR for over65 variable
model5.1 <- gam(con_change1 ~ over65 + deprived + 
                  s(region,bs='mrf',xt=list(nb=nlist3), k=3) + 
                  s(region,bs='mrf',xt=list(nb=nlist3), 
                           by=over65,k=3), 
                data=all_elections_polygons,  family=gaussian, 
               weight=total_vote_19, method='REML')
summary(model5.1)
# df for holding results with simplified constituency boundaries for plotting
reg_extract <- tibble(over65=rep(1,10), 
                      deprived=rep(1,10), 
                      region=levels(regions$region), 
                      `region:over65`=levels(regions$region)) 
# all_elections_polygons_reg_simp <- all_elections_polygons %>% 
#   dplyr::select(-geometry) %>% 
#   st_join(regions_simp)
regions_simp <- regions_simp %>% 
  mutate(gamma_over65 = predict(model5.1, newdata = reg_extract, type='terms')[,4],
#         gamma_deprived = predict(model5.1, newdata = reg_extract, type='terms')[,5],
         rand_slope_over65 = gamma_over65 / wmeans_regions$over65, 
#         rand_slope_deprived = gamma_deprived / wmeans_regions$deprived,
         total_slope_over65 = rand_slope_over65 + model5.1$coefficients[2],
#         total_slope_deprived = rand_slope_deprived + model5.1$coefficients[3]
)
```

#### GAM with CAR region level

##### Deprived

```{r}
model5.2 <- gam(con_change1 ~ over65 + deprived + 
                  s(region,bs='mrf',xt=list(nb=nlist3), k=3) + 
                  s(region,bs='mrf',xt=list(nb=nlist3), 
                           by=deprived,k=2), 
                data=all_elections_polygons,  family=gaussian, 
               weight=total_vote_19, method='REML')
summary(model5.2)
# df for holding results with simplified constituency boundaries for plotting
reg_extract2 <- tibble(over65=rep(1,10), 
                      deprived=rep(1,10), 
                      region=levels(regions$region), 
                      `region:over65`=levels(regions$region))  
regions_simp <- regions_simp %>% 
  mutate(gamma_deprived = predict(model5.2, newdata = reg_extract2, type='terms')[,4],
         rand_slope_deprived = gamma_deprived / wmeans_regions$deprived,
         total_slope_deprived = rand_slope_deprived + model5.2$coefficients[3]
)
rr1 <- ggplot(regions_simp,aes(fill=total_slope_over65)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Over 65") + 
  labs(title = "Fixed + Random Slopes")
rr2 <- ggplot(regions_simp,aes(fill=total_slope_deprived)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Deprived") + 
  labs(title = "Fixed + Random Slopes")
rr3 <- ggplot(regions_simp,aes(fill=rand_slope_over65)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Over 65") + 
  labs(title = "Random Slopes")
rr4 <- ggplot(regions_simp,aes(fill=rand_slope_deprived)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Deprived") + 
  labs(title = "Random Slopes")
```

```{r, fig.height=6, fig.width=12}
# ggarrange(rr1,rr2, 
#           ncol=2, nrow=1, common.legend = FALSE, legend="right")
ggarrange(rr3,rr4, 
          ncol=2, nrow=1, common.legend = FALSE, legend="right")
```

------------------------------------------------------------------------

### Reasons for NaN's in county and region models?

1.  Isle of Wight is a one constituency county?
2.  Many counties have only 2, 3, 4 constituencies?
3.  

### GAM with CAR constituency level

```{r}
# dfs WITH Isle of Wight
all_elections2 <- all_elections %>% 
  mutate(con_change1 = 100*(con_19 - con_17) / (100 - con_17)) %>% 
  filter(!is.na(con_change1)) %>% 
  filter(country != "Scotland") %>%
  mutate(over65 = age_65_to_74 + age_75_to_84 + age_85_to_89 + age_90_plus,
         low_qual = qual_none + qual_level_1,
         deprived = deprived_2 + deprived_3 + deprived_4,
         student = economically_inactive_student,
         leave_EU = leave_hanretty,
         log_density = log(population_density),
         born_elsewhere = born_ireland + born_other_eu + born_other_pre_2004_eu + born_post_2004_eu + born_other,
         density = population_density, 
         con_flip = ifelse(winner_19 == "Conservative" & winner_17 != "Conservative", 1, 0), 
         county = factor(county), 
#         over65 = scale(over65), 
#         deprived = scale(deprived)
         )
all_elections_polygons2 <- left_join(all_elections2 %>% st_drop_geometry(), 
                                    constituency_polygons, by = c("ons_const_id" = "pcon19cd")) %>% 
  st_as_sf()
all_elections_polygons_simp2 <- left_join(all_elections2 %>% st_drop_geometry(), 
                                    constituency_polygons, by = c("ons_const_id" = "pcon19cd")) %>% 
  st_as_sf() %>% 
  st_simplify(dTolerance = 1000)
counties_simp2 <-readRDS(here("data","counties_simp.rds")) %>%
  mutate(county = factor(county))
# df showing seats which flipped to conservatives, for overlaying on map
flip_df2 <- all_elections_polygons_simp2 %>% 
  filter(con_flip == 1)
```

```{r}
# fix and set up contiguity situation
all_elections_polygons2$constituency_name <- factor(all_elections_polygons2$constituency_name)
# contiguity list
nlist2 <- all_elections_polygons2 %>% st_touches()
names(nlist2) <- all_elections_polygons2$constituency_name
# Two island constituencies: make them have contiguity
# 570: Ynys Mon - closest is Arfon: 8
# 253: Isle Of Wight - closest are Portsmouth South: 385, Gosport: 203, 
# Fareham: 189, New Forest East: 330, New Forest West:331
# set them as contiguous to the nearest constituencies, 
# and those constituencies as contiguous to them
nlist2[385]$`Portsmouth South` <- c(253,384)
nlist2[203]$Gosport <- c(189,253)
nlist2[189]$Fareham <- c(203,253,304,384)
nlist2[330]$`New Forest East` <- c(253,331,404,415)
nlist2[331]$`New Forest West` <- c(123,253,330,340,415)
nlist2[8]$Arfon <- c(2,163,570)
nlist2[570]$`Ynys Mon` <- 8
nlist2[253]$`Isle Of Wight` <- c(189,203,330,331,385)
```

```{r}
# first, GAM CAR for over65 variable
model4.1 <- gam(con_change1 ~ over65 + deprived + 
                  s(constituency_name,bs='mrf',xt=list(nb=nlist2), k=20) + 
                  s(constituency_name,bs='mrf',xt=list(nb=nlist2), 
                           by=over65,k=3), 
                data=all_elections_polygons2,  family=gaussian, 
               weight=total_vote_19, method='REML')
summary(model4.1)
# df for holding results with simplified constituency boundaries for plotting
const_extract <- tibble(over65=rep(1,572), 
                        deprived=rep(1,572),
                        constituency_name=levels(all_elections_polygons2$constituency_name), 
                        `constituency_name:over65`=all_elections_polygons2$constituency_name) 
all_elections_polygons_simp2 <- all_elections_polygons_simp2 %>% 
  mutate(gamma_over65 = predict(model4.1, newdata = const_extract, type='terms')[,4],
#         gamma_deprived = predict(model4.1, newdata = const_extract, type='terms')[,5],
         rand_slope_over65 = gamma_over65 / all_elections_polygons2$over65, 
#         rand_slope_deprived = gamma_deprived / all_elections_polygons2$deprived,
         total_slope_over65 = rand_slope_over65 + model4.1$coefficients[2],
#         total_slope_deprived = rand_slope_deprived + model4.1$coefficients[3]
)
```

```{r}
# second, GAM CAR for deprived variable
model4.2 <- gam(con_change1 ~ over65 + deprived + 
                  s(constituency_name,bs='mrf',xt=list(nb=nlist2), k=15) + 
                  s(constituency_name,bs='mrf',xt=list(nb=nlist2), 
                           by=deprived,k=2), 
                data=all_elections_polygons2,  family=gaussian, 
               weight=total_vote_19, method='REML')
summary(model4.2)
# df for holding results with simplified constituency boundaries for plotting
const_extract2 <- tibble(over65=rep(1,572), 
                        deprived=rep(1,572),
                        constituency_name=levels(all_elections_polygons2$constituency_name), 
                        `constituency_name:deprived`=all_elections_polygons2$constituency_name) 
all_elections_polygons_simp2 <- all_elections_polygons_simp2 %>% 
  mutate(gamma_deprived = predict(model4.2, newdata = const_extract, type='terms')[,4],
         rand_slope_deprived = gamma_deprived / all_elections_polygons2$deprived,
         total_slope_deprived = rand_slope_deprived + model4.2$coefficients[3]
)
```

```{r}
s1 <- ggplot() + geom_sf(data=all_elections_polygons_simp2,aes(fill=total_slope_over65),lwd=.2) +
  scale_fill_continuous_diverging(palette = 'Blue_Red3', mid = 0, rev=TRUE, name="Over 65") + 
#  geom_sf(data=counties_simp2, alpha=0,lwd=.25, colour="black") + 
  labs(title = "Fixed + Random Slope") + 
  geom_sf(data=flip_df2, alpha=0,lwd=.35, colour="darkred")
s2 <- ggplot() + geom_sf(data=all_elections_polygons_simp2,aes(fill=total_slope_deprived),lwd=.2) +
  scale_fill_continuous_diverging(palette = 'Blue_Red3', mid = 0, rev=TRUE, name="Deprived") + 
#  geom_sf(data=counties_simp2, alpha=0,lwd=.25, colour="black") + 
  labs(title = "Fixed + Random Slope") + 
  geom_sf(data=flip_df2, alpha=0,lwd=.35, colour="darkred")
s3 <- ggplot() + geom_sf(data=all_elections_polygons_simp2,aes(fill=rand_slope_over65),lwd=.2) +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0, name="Over 65") + 
#  geom_sf(data=counties_simp2, alpha=0,lwd=.25, colour="black") + 
  labs(title = "Random Slope") + 
  geom_sf(data=flip_df2, alpha=0,lwd=.35, colour="darkred")
s4 <- ggplot() + geom_sf(data=all_elections_polygons_simp2,aes(fill=rand_slope_deprived),lwd=.2) +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0, name="Deprived") + 
#  geom_sf(data=counties_simp2, alpha=0,lwd=.25, colour="black") + 
  labs(title = "Random Slope") + 
  geom_sf(data=flip_df2, alpha=0,lwd=.35, colour="darkred")
```

Showing the change in the constituency slope as a result of being in each particular constituency.

Red lines show seats which flipped from non-Conservative to Conservative.

```{r, fig.width=12, fig.height=6}
ggarrange(s1,s2,
          ncol=2, nrow=1, common.legend = FALSE, legend="right")
ggarrange(s3,s4, 
          ncol=2, nrow=1, common.legend = FALSE, legend="right")
```

### GWR

```{r}

coords <- st_centroid(all_elections_polygons2$geometry) %>%
  st_coordinates()

GWRbandwidth <- gwr.sel(con_change1 ~ over65 + deprived, 
                data=all_elections_polygons2, coords=coords, adapt=T)

GWRbandwidth

#run the gwr model
gwr.model = gwr(con_change1 ~ over65 + deprived, 
                data=all_elections_polygons2, coords=coords, 
                adapt=GWRbandwidth, hatmatrix=TRUE, se.fit=TRUE) 

gwr.model


```

```{r, fig.width=12, fig.height=12}

# non-interaction variables
gwr_table1 <- as.data.frame(gwr.model$SDF) %>% 
  cbind(all_elections_polygons_simp2$constituency_name) %>% 
  cbind(all_elections_polygons_simp2$county) %>% 
  mutate(county = all_elections_polygons_simp2$county, 
         constituency_name = `all_elections_polygons_simp2$constituency_name`, 
         intercept = `X.Intercept.`, 
         intercept_se = `X.Intercept._se`, 
         z_over65_se = 1.96*over65_se, 
         z_deprived_se = 1.96*deprived_se) %>% 
  select(constituency_name, county, intercept, over65, deprived, intercept_se, over65_se, deprived_se, z_over65_se, z_deprived_se)

ggplot(data = gwr_table1, aes(y = over65, x = constituency_name, ymin = over65-z_over65_se, ymax = over65+z_over65_se)) +
  geom_errorbar(position = position_dodge(width = 0.2), width = 0.1) +
  geom_point(position = position_dodge(width = 0.2)) +
  coord_flip() + 
  geom_hline(yintercept = 0, colour="darkred") +
  scale_colour_manual(values = c("grey", "black")) +
  theme_classic() + 
  labs(title = "GWR Coefficient: 95% Confidence Interval", 
       subtitle = "Over 65", 
       colour = "County contains\nnew Conservative\nconstituencies") +
  ylab("Value") + 
  xlab("Constituency") +
  facet_wrap(~county)

ggplot(data = gwr_table1, aes(y = deprived, x = constituency_name, ymin = deprived-z_deprived_se, ymax = deprived+z_deprived_se)) +
  geom_errorbar(position = position_dodge(width = 0.2), width = 0.1) +
  geom_point(position = position_dodge(width = 0.2)) +
  coord_flip() + 
  geom_hline(yintercept = 0, colour="darkred") +
  scale_colour_manual(values = c("grey", "black")) +
  theme_classic() + 
  labs(title = "GWR Coefficient: 95% Confidence Interval", 
       subtitle = "Deprived", 
       colour = "County contains\nnew Conservative\nconstituencies") +
  ylab("Value") + 
  xlab("Constituency") + 
  facet_wrap(~county)

```

```{r, fig.height=6, fig.width=12}

gwr_table1 <- gwr_table1 %>% 
  cbind(all_elections_polygons_simp2$geometry) %>% 
  st_as_sf()

j1 <- ggplot(gwr_table1) + 
  geom_sf(aes(fill=over65), lwd=0.1) +
  geom_sf(data=flip_df2, alpha=0,lwd=.2, colour="darkred") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Over 65") + 
  labs(title = "GWR Coefficient")

j2 <- ggplot(gwr_table1) + 
  geom_sf(aes(fill=deprived), lwd=0.1) +
  geom_sf(data=flip_df2, alpha=0,lwd=.2, colour="darkred") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Deprived") + 
  labs(title = "GWR Coefficient")

ggarrange(j1,j2, 
          ncol=2, nrow=1, common.legend = FALSE, legend="right")

```

```{r, fig.height=6, fig.width=12}
gwr_table1 <- gwr_table1 %>% 
  mutate(significance_over65 = factor(
    ifelse(over65-z_over65_se <0 & over65+z_over65_se<0, "negative", 
                      ifelse(over65-z_over65_se>0 & over65+z_over65_se>0, "positive", "not significant"))),
         significance_deprived = factor(
           ifelse(deprived-z_deprived_se <0 & deprived+z_deprived_se<0, "negative", 
                      ifelse(deprived-z_deprived_se>0 & deprived+z_deprived_se>0, "positive", "not significant")))
         )

k1 <- ggplot(gwr_table1) + 
  geom_sf(aes(fill=significance_over65), lwd=0.1) + 
  labs(title = "GWR Coefficient: Over 65 (95% CI)", 
       subtitle = "Red Lines Denote New Conservative Wins", 
       fill = "Neg/Pos\nSlope") + 
  scale_fill_manual(values = c("negative" = "lightblue3",
                                "positive"="burlywood3",
                                "not significant"="white")) + 
  geom_sf(data=flip_df, alpha=0,lwd=.35, colour="darkred")

k2 <- ggplot(gwr_table1) + 
  geom_sf(aes(fill=significance_deprived), lwd=0.1) + 
  labs(title = "GWR Coefficient: Deprived (95% CI)", 
       subtitle = "Red Lines Denote New Conservative Wins", 
       fill = "Neg/Pos\nSlope") + 
  scale_fill_manual(values = c("negative" = "lightblue3",
                                "positive"="burlywood3",
                                "not significant"="white")) + 
  geom_sf(data=flip_df, alpha=0,lwd=.35, colour="darkred")

ggarrange(k1,k2,  
          ncol=2, nrow=1, common.legend = FALSE, legend="right")
```

```{r, fig.height=6, fig.width=12}
# 
# # LISA clusters for coefficients of change variables
# 
# # construct two matrices for spatial analysis
# neighbours <- poly2nb(all_elections_polygons2, queen=T)
# weights <- nb2listw(neighbours, style="W", zero.policy = T)
# 
# gwr_table1 <- as.data.frame(gwr_table1)
# # set arrangement the 8 plots
# par(mfrow = c(1,2))
# 
# for (i in 4:5) {
# 
# #######
# 
# locali <- localmoran(gwr_table1[,i], weights, zero.policy = TRUE)
# 
# ######
# 
# # Plot LISA clusters
# 
# quadrant <- vector(mode="numeric",length=nrow(locali))
# 
# # centers the variable of interest around its mean
# m.conchange <- gwr_table1[,i] - mean(gwr_table1[,i])     
# 
# # centers the local Moran's around the mean
# m.local <- locali[,1] - mean(locali[,1])    
# 
# # significance threshold
# signif <- 0.1 
# 
# # builds a data quadrant, define the high-high, low-low, low-high and high-low categories,
# # andplaces non-significant Moran in the category 0.
# quadrant[m.conchange >0 & m.local>0] <- 4  
# quadrant[m.conchange <0 & m.local<0] <- 1      
# quadrant[m.conchange <0 & m.local>0] <- 2
# quadrant[m.conchange >0 & m.local<0] <- 3
# quadrant[locali[,5]>signif] <- 0   
# 
# # plot in r
# brks <- c(0,1,2,3,4)
# colors <- c("white","blue",rgb(0,0,1,alpha=0.4),rgb(1,0,0,alpha=0.4),"red")
# plot(all_elections_polygons_simp2$geometry, border="gray", col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
# box()
# legend("bottomleft", legend = c("insignificant","low-low","low-high","high-low","high-high"),
#        fill=colors, bty="n")
# title(main = paste("LISA Clusters: ", names(gwr_table1)[i]))
# 
# }

```

### PCA

```{r}
vars2 <- all_elections_polygons2 %>% 
  st_drop_geometry() %>% 
  dplyr::select(c("over65", "deprived"))

res.pca <- prcomp(vars2)
res.pca

fviz_pca_biplot(res.pca, repel = TRUE,
                col.var = "darkblue", # Variables color
                col.ind = "grey"  # Individuals color
                )

# Results for individuals
res.ind <- get_pca_ind(res.pca)
# results for variables
res.var <- get_pca_var(res.pca)
# Varimax rotation
v <- varimax(res.var$coord[,1:2], normalize = TRUE)

scores <- res.ind$coord[,1:2] %*% v$rotmat

pca_df <- as.data.frame(cbind(all_elections_polygons2$con_change1, scores))
colnames(pca_df) <- c("con_change", "PC1", "PC2")

mod_pca <- lm(con_change ~ PC1 + PC2, data = pca_df)
summary(mod_pca)

coef_over65_pca <- (v$loadings[1,1] * as.numeric(mod_pca$coefficients[2])) + 
  (v$loadings[1,2] * as.numeric(mod_pca$coefficients[3]))
coef_deprived_pca <- (v$loadings[2,1] * as.numeric(mod_pca$coefficients[2])) + 
  (v$loadings[2,2] * as.numeric(mod_pca$coefficients[3]))


table_pca <- as.data.frame(rbind(coef_over65_pca, coef_deprived_pca)) %>% 
  cbind(names(vars2)) 
  
colnames(table_pca) <- c("Coefficient","Variable")


```

### GWR PCA

```{r}

# now the GWR model with GWPCA components
GWRbandwidth.pca <- gwr.sel(con_change ~ PC1 + PC2, 
                        data=pca_df, coords=coords, adapt=T)

GWRbandwidth.pca

#run the gwr model
gwr.model.pca = gwr(con_change ~ PC1 + PC2, 
                        data=pca_df, coords=coords, 
                adapt=GWRbandwidth.pca, hatmatrix=TRUE, se.fit=TRUE) 

# before loop, define vectors
coef_over65_gwrpca <- vector()
coef_deprived_gwrpca <- vector()


gwrPC1 <- gwr.model.pca$SDF$PC1
gwrPC2 <- gwr.model.pca$SDF$PC2


# calculate coefficient for each variable by same technique as before
for (i in 1:572) {
coef_over65_gwrpca[i] <- as.vector((v$loadings[1,1] * gwrPC1[i])) + 
  (v$loadings[1,2] * gwrPC2[i])
coef_deprived_gwrpca[i] <- as.vector((v$loadings[2,1] * gwrPC1[i])) + 
  (v$loadings[2,2] * gwrPC2[i])

}

# bind into a table
gwr_pca_table <- as.data.frame(cbind(coef_over65_gwrpca, coef_deprived_gwrpca)) %>% 
  cbind(all_elections_polygons_simp2) %>% 
  st_as_sf()

```

```{r, fig.height=6, fig.width=12}

zz1 <- ggplot(gwr_pca_table) + 
  geom_sf(aes(fill=coef_over65_gwrpca), lwd=0.1) + 
  geom_sf(data=flip_df2, alpha=0,lwd=0.2, colour="darkred") + 
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Over65") + 
  labs(title = "GWR with PCA Slopes")

zz2<- ggplot(gwr_pca_table) + 
  geom_sf(aes(fill=coef_deprived_gwrpca), lwd=0.1) +
  geom_sf(data=flip_df2, alpha=0,lwd=.2, colour="darkred") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Deprived") + 
  labs(title = "GWR with PCA Slopes")

ggarrange(zz1,zz2, 
          ncol=2, nrow=1, common.legend = FALSE, legend="right")

```

```{r, fig.height=6, fig.width=12}
# 
# # LISA clusters for coefficients of change variables
# 
# 
# gwr_pca_table <- as.data.frame(gwr_pca_table)
# # set arrangement the 8 plots
# par(mfrow = c(1,2))
# 
# for (i in 1:2) {
# 
# #######
# 
# locali <- localmoran(gwr_pca_table[,i], weights, zero.policy = TRUE)
# 
# ######
# 
# # Plot LISA clusters
# 
# quadrant <- vector(mode="numeric",length=nrow(locali))
# 
# # centers the variable of interest around its mean
# m.conchange <- gwr_pca_table[,i] - mean(gwr_pca_table[,i])     
# 
# # centers the local Moran's around the mean
# m.local <- locali[,1] - mean(locali[,1])    
# 
# # significance threshold
# signif <- 0.1 
# 
# # builds a data quadrant, define the high-high, low-low, low-high and high-low categories,
# # andplaces non-significant Moran in the category 0.
# quadrant[m.conchange >0 & m.local>0] <- 4  
# quadrant[m.conchange <0 & m.local<0] <- 1      
# quadrant[m.conchange <0 & m.local>0] <- 2
# quadrant[m.conchange >0 & m.local<0] <- 3
# quadrant[locali[,5]>signif] <- 0   
# 
# # plot in r
# brks <- c(0,1,2,3,4)
# colors <- c("white","blue",rgb(0,0,1,alpha=0.4),rgb(1,0,0,alpha=0.4),"red")
# plot(all_elections_polygons_simp2$geometry, border="gray", col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
# box()
# legend("bottomleft", legend = c("insignificant","low-low","low-high","high-low","high-high"),
#        fill=colors, bty="n")
# title(main = paste("LISA Clusters: ", names(gwr_pca_table)[i]))
# 
# }

```

### GWR GWPCA

```{r}
# first, perform the GWPCA

rownames(coords) <- NULL
d1s <- SpatialPointsDataFrame(coords, vars2)

bw.choice <- bw.gwpca(d1s,vars=colnames(d1s@data),k=2)
pca.gw.auto  <- gwpca(d1s,vars=colnames(d1s@data),bw=bw.choice,k=2,scores = TRUE)

scores <- as.data.frame(pca.gw.auto$pca$scores)
PC1gw <- scores[,1]
PC2gw <- scores[,2]


pcagw.df <- as.data.frame(cbind(all_elections_polygons_simp2$con_change1, PC1gw, PC2gw))
colnames(pcagw.df) <- c("con_change", "PC1gw", "PC2gw")

# pcagw.df <- as.data.frame(cbind(df19.17$con, PC1gw, PC2gw, df19.17$geometry)) %>% 
#   st_as_sf()
# colnames(pcagw.df) <- c("con", "PC1gw", "PC2gw", "geometry")
# str(pcagw.df)

# now the GWR model with GWPCA components
GWRbandwidth.gwpca <- gwr.sel(con_change ~ PC1gw + PC2gw, 
                        data=pcagw.df, coords=coords, adapt=T)

GWRbandwidth.gwpca

#run the gwr model
gwr.model.gwpca = gwr(con_change ~ PC1gw + PC2gw, 
                        data=pcagw.df, coords=coords, 
                adapt=GWRbandwidth.gwpca, hatmatrix=TRUE, se.fit=TRUE) 


# before loop, define vectors
coef_over65_gwpca <- vector()
coef_deprived_gwpca <- vector()


# loadings from gw pca
lds <- as.data.frame(pca.gw.auto$loadings)

gwPC1 <- gwr.model.gwpca$SDF$PC1gw
gwPC2 <- gwr.model.gwpca$SDF$PC2gw

# calculate coefficient for each variable by same technique as before
for (i in 1:572) {
coef_over65_gwpca[i] <- as.vector((lds[i,"over65.PC1"] * gwPC1[i])) + 
  (lds[i,"over65.PC2"] * gwPC2[i])
coef_deprived_gwpca[i] <- as.vector((lds[i,"deprived.PC1"] * gwPC1[i])) + 
  (lds[i,"deprived.PC2"] * gwPC2[i])

}

# bind into a table
gwr_gwpca_table <- as.data.frame(cbind(coef_over65_gwpca, coef_deprived_gwpca)) %>% 
  cbind(all_elections_polygons_simp2) %>% 
  st_as_sf()

```

```{r, fig.height=6, fig.width=12}

yy1 <- ggplot(gwr_gwpca_table) + 
  geom_sf(aes(fill=coef_over65_gwrpca), lwd=0.1) + 
  geom_sf(data=flip_df2, alpha=0,lwd=0.2, colour="darkred") + 
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Over65") + 
  labs(title = "GWR with PCA Slopes")

yy2<- ggplot(gwr_gwpca_table) + 
  geom_sf(aes(fill=coef_deprived_gwrpca), lwd=0.1) +
  geom_sf(data=flip_df2, alpha=0,lwd=.2, colour="darkred") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Deprived") + 
  labs(title = "GWR with PCA Slopes")

ggarrange(yy1,yy2, 
          ncol=2, nrow=1, common.legend = FALSE, legend="right")

```

```{r, fig.height=6, fig.width=12}
# 
# # LISA clusters for coefficients of change variables
# 
# 
# gwr_gwpca_table <- as.data.frame(gwr_gwpca_table)
# # set arrangement the 8 plots
# par(mfrow = c(1,2))
# 
# for (i in 1:2) {
# 
# #######
# 
# locali <- localmoran(gwr_gwpca_table[,i], weights, zero.policy = TRUE)
# 
# ######
# 
# # Plot LISA clusters
# 
# quadrant <- vector(mode="numeric",length=nrow(locali))
# 
# # centers the variable of interest around its mean
# m.conchange <- gwr_gwpca_table[,i] - mean(gwr_gwpca_table[,i])     
# 
# # centers the local Moran's around the mean
# m.local <- locali[,1] - mean(locali[,1])    
# 
# # significance threshold
# signif <- 0.1 
# 
# # builds a data quadrant, define the high-high, low-low, low-high and high-low categories,
# # andplaces non-significant Moran in the category 0.
# quadrant[m.conchange >0 & m.local>0] <- 4  
# quadrant[m.conchange <0 & m.local<0] <- 1      
# quadrant[m.conchange <0 & m.local>0] <- 2
# quadrant[m.conchange >0 & m.local<0] <- 3
# quadrant[locali[,5]>signif] <- 0   
# 
# # plot in r
# brks <- c(0,1,2,3,4)
# colors <- c("white","blue",rgb(0,0,1,alpha=0.4),rgb(1,0,0,alpha=0.4),"red")
# plot(all_elections_polygons_simp2$geometry, border="gray", col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
# box()
# legend("bottomleft", legend = c("insignificant","low-low","low-high","high-low","high-high"),
#        fill=colors, bty="n")
# title(main = paste("LISA Clusters: ", names(gwr_gwpca_table)[i]))
# 
# }

```

### Are Residuals Spatially Correlated?

#### Maps of Residuals from OLS and GAM with CAR models

```{r, fig.height=6, fig.width=6}

mod1_resids <- model1$residuals
mod1_resids_df <- cbind(all_elections_polygons_simp$geometry,mod1_resids) %>% 
  as.data.frame() %>% 
  st_as_sf(crs=4326) %>% 
  mutate(mod1_resids = as.numeric(mod1_resids))
m1 <- ggplot(mod1_resids_df) + 
  geom_sf(aes(fill = mod1_resids),lwd=0.1)  +
  scale_fill_continuous_diverging(palette = 'Green-Orange', mid = 0,
                       name= "OLS Residuals")         
m1
```

```{r, fig.height=12, fig.width=12}

mod3.1_resids <- model3.1$residuals
mod3.1_resids_df <- cbind(all_elections_polygons_simp$geometry,mod3.1_resids) %>% 
  as.data.frame() %>% 
  st_as_sf(crs=4326) %>% 
  mutate(mod3.1_resids = as.numeric(mod3.1_resids))
m3.1 <- ggplot(mod1_resids_df) + 
  geom_sf(aes(fill = mod3.1_resids),lwd=0.1)  +
  scale_fill_continuous_diverging(palette = 'Green-Orange', mid = 0,
                       name= "GAM with CAR:\ncounty level\nOver 65\nResiduals") 

mod3.2_resids <- model3.2$residuals
mod3.2_resids_df <- cbind(all_elections_polygons_simp$geometry,mod3.2_resids) %>% 
  as.data.frame() %>% 
  st_as_sf(crs=4326) %>% 
  mutate(mod3.2_resids = as.numeric(mod3.2_resids))
m3.2 <- ggplot(mod1_resids_df) + 
  geom_sf(aes(fill = mod3.2_resids),lwd=0.1)  +
  scale_fill_continuous_diverging(palette = 'Green-Orange', mid = 0,
                       name= "GAM with CAR:\ncounty level\nDeprived\nResiduals")

mod4.1_resids <- model4.1$residuals
mod4.1_resids_df <- cbind(all_elections_polygons_simp2$geometry,mod4.1_resids) %>% 
  as.data.frame() %>% 
  st_as_sf(crs=4326) %>% 
  mutate(mod4.1_resids = as.numeric(mod4.1_resids))
m4.1 <- ggplot(mod4.1_resids_df) + 
  geom_sf(aes(fill = mod4.1_resids),lwd=0.1)  +
  scale_fill_continuous_diverging(palette = 'Green-Orange', mid = 0,
                       name= "GAM with CAR:\nconstituency level\nOver 65\nResiduals")

mod4.2_resids <- model4.2$residuals
mod4.2_resids_df <- cbind(all_elections_polygons_simp$geometry,mod4.2_resids) %>% 
  as.data.frame() %>% 
  st_as_sf(crs=4326) %>% 
  mutate(mod4.2_resids = as.numeric(mod4.2_resids))
m4.2 <- ggplot(mod4.2_resids_df) + 
  geom_sf(aes(fill = mod4.2_resids),lwd=0.1)  +
  scale_fill_continuous_diverging(palette = 'Green-Orange', mid = 0,
                       name= "GAM with CAR:\nconstituency level\nDeprived\nResiduals")

mod5.1_resids <- model5.1$residuals
mod5.1_resids_df <- cbind(all_elections_polygons_simp$geometry,mod5.1_resids) %>% 
  as.data.frame() %>% 
  st_as_sf(crs=4326) %>% 
  mutate(mod5.1_resids = as.numeric(mod5.1_resids))
m5.1 <- ggplot(mod5.1_resids_df) + 
  geom_sf(aes(fill = mod5.1_resids),lwd=0.1)  +
  scale_fill_continuous_diverging(palette = 'Green-Orange', mid = 0,
                       name= "GAM with CAR:\nregion level\nOver 65\nResiduals")

mod5.2_resids <- model5.2$residuals
mod5.2_resids_df <- cbind(all_elections_polygons_simp$geometry,mod5.2_resids) %>% 
  as.data.frame() %>% 
  st_as_sf(crs=4326) %>% 
  mutate(mod5.2_resids = as.numeric(mod5.2_resids))
m5.2 <- ggplot(mod5.2_resids_df) + 
  geom_sf(aes(fill = mod5.2_resids),lwd=0.1)  +
  scale_fill_continuous_diverging(palette = 'Green-Orange', mid = 0,
                       name= "GAM with CAR:\nregion level\nDeprived\nResiduals")

ggarrange(m3.1,m3.2,m4.1,m4.2,m5.1,m5.2, 
          ncol=2, nrow=3, common.legend = FALSE, legend="right")

```


#### Residuals on LISA for the various models

OLS 

```{r}
do.lisa(mod1.1_resids)
```

LME 

```{r}
do.lisa(residuals(model2.2))
```

GAM with CAR: county level Over 65 

```{r}
do.lisa(mod3.1_resids)
```


GAM with CAR: county level Deprived 

```{r}
do.lisa(mod3.2_resids)
#do.lisa(mod4.1_resids)
#do.lisa(mod4.2_resids)
```

GAM with CAR: region level Over 65 

```{r}
do.lisa(mod5.1_resids)
```

GAM with CAR: region level Deprived 

```{r}
do.lisa(mod5.2_resids)
```


GAM with CAR: county level Over 65 

```{r}
all_elections_polygons_simp_table <- as.data.frame(all_elections_polygons_simp) %>% 
  st_as_sf()
neighbours2 <- poly2nb(all_elections_polygons_simp_table, queen=T)
weights_for_mods <- nb2listw(neighbours2, style="W", zero.policy = T)

test3.1 <- moran.test(model3.1$residuals,weights_for_mods,zero.policy = TRUE)
test3.1$estimate
test3.1$p.value
```

GAM with CAR: county level Deprived

```{r}
test3.2 <- moran.test(model3.2$residuals,weights_for_mods,zero.policy = TRUE)
test3.2$estimate
test3.2$p.value

all_elections_polygons_simp2_table <- as.data.frame(all_elections_polygons_simp2) %>% 
  st_as_sf()
neighbours3 <- poly2nb(all_elections_polygons_simp2_table, queen=T)
weights_for_mods3 <- nb2listw(neighbours3, style="W", zero.policy = T)
```

GAM with CAR: constituency level Over 65

```{r}
test4.1 <- moran.test(model4.1$residuals,weights_for_mods3,zero.policy = TRUE)
test4.1$estimate
test4.1$p.value
```

GAM with CAR: constituency level Deprived

```{r}
test4.2 <- moran.test(model4.2$residuals,weights_for_mods3,zero.policy = TRUE)
test4.2$estimate
test4.2$p.value
```

GAM with CAR: region level Over 65

```{r}
test5.1 <- moran.test(model5.1$residuals,weights_for_mods,zero.policy = TRUE)
test5.1$estimate
test5.1$p.value
```

GAM with CAR: region level Deprived

```{r}
test5.2 <- moran.test(model5.2$residuals,weights_for_mods,zero.policy = TRUE)
test5.2$estimate
test5.2$p.value
```

OLS

```{r}
test1 <- moran.test(model1$residuals,weights_for_mods,zero.policy = TRUE)
test1$estimate
test1$p.value
```



## Experiments with removing London
##### seems to get rid of NaN for over65 but not for deprived...
#### GAM with CAR: county level

##### Over 65

```{r}

# re-read data before manipulating it
counties <- readRDS(here("data", "counties.rds")) %>% 
  subset(county != "Isle of Wight") %>% 
  mutate(county = factor(county))
# df with simplified county sf polygons for making maps
counties_simp <-readRDS(here("data","counties_simp.rds")) %>% 
  subset(county != "Isle of Wight") %>% 
  mutate(county = factor(county))
# weighted means for variables at county level, weights by size of electorate
wmeans <- readRDS(here("data","wmeans.RDS")) %>% 
  subset(county != "Isle of Wight")

# make adjacency list for counties
nlist <- counties %>% filter(county!="London") %>% st_touches()
names(nlist) <- counties$county[-30]
counties <- counties[-30,]
counties$county <- factor(counties$county)
wmeans <- wmeans[-30,]
all_elections_polygonsnl <-all_elections_polygons %>% filter(region!="London")
# Isle of Wight[26] is island county. Make it adjacent to West Sussex[51] and Hampshire[22]
# nlist[51]$`West Sussex` <- c(16,22,26,46)
# nlist[22]$Hampshire <- c(3,13,26,46,51,53)
# nlist[26]$`Isle of Wight` <- c(22,51)
```

```{r}

# suffix nl to objects will indicate not London...

model3.1nl <- gam(con_change1 ~ over65 + deprived + 
                 s(county,bs='mrf',xt=list(nb=nlist)) +
                 s(county,bs='mrf',xt=list(nb=nlist), 
                   by=over65,k=2),
               data=all_elections_polygonsnl, family=gaussian, 
               weight=total_vote_19, method='REML')
summary(model3.1nl)
county_extract1nl <- tibble(over65=rep(1,51), 
                          deprived=rep(1,51),
                          county=levels(counties$county),
                         `county:over65`=levels(counties$county)) 
# df for holding results with simplified county boundaries for plotting
counties_simp1nl <- counties_simp[-30,] %>%
  mutate(agamma_i = predict(model3.1nl, newdata = county_extract1nl))

counties_simp1nl <- counties_simp1nl %>% 
  mutate(gamma_i = predict(model3.1nl,  newdata = county_extract1nl, type='terms')[,4], 
         rand_slope_over65 = (gamma_i / wmeans$over65), 
         fix_slope_over65 = rep(model3.1$coefficients[2]), 
         total_slope_over65 = rand_slope_over65 + fix_slope_over65)
a3.1nl <- ggplot(counties_simp1nl,aes(fill=agamma_i)) + 
  geom_sf(lwd=.25, colour="black") +
  scale_fill_distiller(name=expression(alpha+gamma[i]),direction=1)
b3.1nl <- ggplot(counties_simp1nl,aes(fill=rand_slope_over65)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_distiller(type='div',
                       name=expression(gamma[over65]))
c3.1nl <- ggplot(counties_simp1nl,aes(fill=fix_slope_over65)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Over 65") + 
  labs(title = "Random Slope")
d3.1nl <- ggplot(counties_simp1nl,aes(fill=total_slope_over65)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = mean(counties_simp1nl$total_slope_over65),
                       name= "Over 65") + 
  labs(title = "Fixed + Random Slope")

a3.1nl
b3.1nl
c3.1nl
d3.1nl
```


```{r}
model3.2nl <- gam(con_change1 ~ over65 + deprived + 
                 s(county,bs='mrf',xt=list(nb=nlist)) +
                 s(county,bs='mrf',xt=list(nb=nlist), 
                   by=deprived,k=2),
               data=all_elections_polygonsnl, family=gaussian, 
               weight=total_vote_19, method='REML')
summary(model3.2nl)
county_extract2nl <- tibble(over65=rep(1,51), 
                          deprived=rep(1,51),
                          county=levels(counties$county),
                         `county:deprived`=levels(counties$county)) 
# df for holding results with simplified county boundaries for plotting
counties_simp2nl <- counties_simp[-30,] %>%
  mutate(agamma_i = predict(model3.2nl, newdata = county_extract1nl))

counties_simp2nl <- counties_simp2nl %>% 
  mutate(gamma_i = predict(model3.2nl,  newdata = county_extract2nl, type='terms')[,4], 
         rand_slope_deprived = (gamma_i / wmeans$deprived), 
         fix_slope_deprived = rep(model3.1$coefficients[2]), 
         total_slope_deprived = rand_slope_deprived + fix_slope_deprived)
a3.2nl <- ggplot(counties_simp2nl,aes(fill=agamma_i)) + 
  geom_sf(lwd=.25, colour="black") +
  scale_fill_distiller(name=expression(alpha+gamma[i]),direction=1)
b3.2nl <- ggplot(counties_simp2nl,aes(fill=rand_slope_deprived)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_distiller(type='div',
                       name=expression(gamma[deprived]))
c3.2nl <- ggplot(counties_simp2nl,aes(fill=fix_slope_deprived)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = 0,
                       name= "Deprived") + 
  labs(title = "Random Slope")
d3.2nl <- ggplot(counties_simp2nl,aes(fill=total_slope_deprived)) + geom_sf(lwd=.25, colour="black") +
  scale_fill_continuous_diverging(palette = 'Vik', mid = mean(counties_simp2nl$total_slope_deprived),
                       name= "Deprived") + 
  labs(title = "Fixed + Random Slope")

a3.2nl
b3.2nl
c3.2nl
d3.2nl
```

## LME without correlation, then use ANOVA... 

##### model2.2a <- lmer(con_change1 ~ 1 + over65 + deprived + (over65 + deprived||county), data=all_elections_polygons) 

### Linear Mixed Model - Random Intercept and Slope by county

```{r, fig.width=4, fig.height=4}
model2.2a <- lmer(con_change1 ~ 1 + over65 + deprived + (over65 + deprived||county), 
               data=all_elections_polygons)
summary(model2.2a)

anova(model2.2, model2.2a)
#the original, model2.2, without removing correlation, is a better fit model

```










